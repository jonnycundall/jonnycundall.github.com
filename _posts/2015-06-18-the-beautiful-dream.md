---
layout: post
title: "The Beautiful Dream"
description: ""
category: 
tags: [fp, f#, c#]
---
{% include JB/setup %}
<p>So, functional programming. The dream. The beautiful dream.</p>

<p>Here I am hacking away in C#. It's nice, I know where I am. I make classes, the runtime makes objects out of them. The objects do stuff if you ask them nicely. These little chunks of code clunk together in a way I can understand. This is how we roll. <p>
<p>But we've heard of another way. A magic way. No more building boilerplate object things. No more blackened oily hands from debugging the chugging motors of logic. The functional programmer sits on a cushion, in the lotus position, in a clean white room with no furniture. He looks out of a huge picture window, his eyes fixed on the horizon. After an hour of thought he strokes his well trimmed beard. Then he types, fingers floating above the machine. He writes a program which does the same job as your object-oriented, diesel powered, gear crunching engine. It does the same job, using only delicate, yet definite clear brush strokes. It is a thing of beauty. It uses a few lines of code, each one a powerful spell. Together, they form a poem, an ode to the soul of the problem.</p>
<p>Ah. The theory. So lovely. </p>
<p>The trouble is that I've read a good amount about functional programming. I've learned some Haskell, some F#, some Clojure. I followed the exercises. I solved the problems. Yet when I have a real world problem. I can't really imagine how I could solve it with a functional programming language. The gates to the magical world are still closed to me.</p>
<p>But I can't give up yet. There must be a way to find the key. I can't just write a whimsical blog. I have a plan.</p>
<p>I aim to start with something I understand. A nice OO engine with all the usual parts, ready to chug along completing a task. It'll be C#, since that's what I know. Then I'll convert it, piece by piece, into F#. Then what will I have. Yes, I'll have a working program in a functionally oriented language. It will, however look terrible. I'll be making an engine out of butterflies, stuck together with oil.</p>
<p>Once I have something working, though, I'm going to make it better. I'm going to find all the ways that functional programming can cut through all this mess with elegance. Through a sequence of refactoring steps I will get something which works and is pretty functional. Most importantly I will have learned something. In all likelihood, the thing that I will have learned is not to do this, and how terrible an idea it is.</p> 

